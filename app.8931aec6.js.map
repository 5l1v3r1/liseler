{"version":3,"sources":["webpack:///app.8931aec6.js","webpack:///./src/markerClusterer.js","webpack:///./src/getCurrentLocation.js","webpack:///./src/index.js","webpack:///./src/map.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","OGwZ","RFWi","__webpack_exports__","MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","minZoom","maxZoom","Math","min","mapTypes","getMapTypeId","max","resetViewport","redraw","length","Object","keys","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","_typeof","Symbol","iterator","obj","constructor","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","size","i","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","markersCopy","slice","r","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","window","setTimeout","distanceBetweenPoints_","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","d","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","l","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join","o","result","name","hasOwnProperty","Ymb8","getCurrentLocation","Promise","resolve","reject","navigator","geolocation","Error","getCurrentPosition","position","coords","latitude","lon","longitude","error","errorMessage","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","gU42","lVK7","_asyncToGenerator","fn","gen","arguments","step","key","arg","info","value","done","then","err","defineProperty","__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator__","__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default","n","__WEBPACK_IMPORTED_MODULE_1__css_sfUi_css__","__WEBPACK_IMPORTED_MODULE_2__css_snazzyInfoWindow_css__","__WEBPACK_IMPORTED_MODULE_3__css_index_css__","__WEBPACK_IMPORTED_MODULE_4__map__","__WEBPACK_IMPORTED_MODULE_5__getCurrentLocation__","_this","main","_ref","mark","_callee2","mapNode","markersData","loading","filterLinks","showAll","nearLocationButton","wrap","_context2","prev","next","getElementById","sent","querySelectorAll","Array","from","forEach","filterLink","type","getAttribute","newMarkers","filter","schoolData","schoolType","setAttribute","addEventListener","preventDefault","close","querySelector","_callee","_context","textContent","disabled","panTo","setZoom","t0","alert","message","finish","stop","onload","mLai","zD9L","createMap","getMarkersData","createMarkers","createCluster","__WEBPACK_IMPORTED_MODULE_1_snazzy_info_window__","__WEBPACK_IMPORTED_MODULE_1_snazzy_info_window___default","__WEBPACK_IMPORTED_MODULE_2__markerClusterer__","_extends","assign","target","source","call","TURKEY_POSITION","CLUSTER_OPTIONS","imagePath","domNode","Map","mapTypeId","MapTypeId","ROADMAP","mapTypeControlOptions","MapTypeControlStyle","HORIZONTAL_BAR","ControlPosition","RIGHT_TOP","streetViewControl","fullscreenControl","getMarkerIcon","getMarkerInfoStyle","backgroundColor","color","response","data","fetch","json","abrupt","Marker","title","schoolName","icon","placement","content","website","fullName","showCloseButton","closeOnMapClick","closeWhenOthersOpen","border","shadow","maxWidth","padding"],"mappings":"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","file":"app.8931aec6.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"+prg\");\nmodule.exports = __webpack_require__(\"lVK7\");\n\n\n/***/ }),\n\n/***/ \"OGwZ\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"RFWi\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* eslint-disable */\n\n// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.1\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] || this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] || this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function () {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(that.map_.maxZoom || 100, that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);\n    zoom = Math.min(Math.max(zoom, minZoom), maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function () {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function (obj1, obj2) {\n  return function (object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }.apply(obj1, [obj2]);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function () {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function () {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function () {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function () {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function (styles) {\n  this.styles_ = styles;\n};\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function () {\n  return this.styles_;\n};\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function () {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function () {\n  return this.averageCenter_;\n};\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function () {\n  return this.markers_.length;\n};\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function (maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function () {\n  return this.maxZoom_;\n};\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function (markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function (calculator) {\n  this.calculator_ = calculator;\n};\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function () {\n  return this.calculator_;\n};\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; marker = markers[i]; i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function (marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function () {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function (marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; marker = markersCopy[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function (ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function () {\n  return this.clusters_.length;\n};\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function () {\n  return this.map_;\n};\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function (map) {\n  this.map_ = map;\n};\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function () {\n  return this.gridSize_;\n};\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function (size) {\n  this.gridSize_ = size;\n};\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function () {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function (size) {\n  this.minClusterSize_ = size;\n};\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function (bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function () {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function (opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function () {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function () {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function () {\n  this.createClusters_();\n};\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n */\nMarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function (marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function () {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(), this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(), markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function (marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function (marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function () {\n  return this.markerClusterer_;\n};\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function () {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function () {\n  return this.markers_.length;\n};\n\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\nCluster.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function () {\n  return this.center_;\n};\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function (marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function () {\n  return this.map_;\n};\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function () {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function () {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function () {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function () {\n    that.triggerClusterClick();\n  });\n};\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function () {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function () {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function () {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function () {\n  this.setMap(null);\n};\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function () {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function (sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function () {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function (center) {\n  this.center_ = center;\n};\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function (pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (_typeof(this.anchor_) === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 && this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) + 'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 && this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) + 'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' + pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' + txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] = MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] = MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] = MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] = MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] = MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] = MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] = MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] = MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] = MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] = MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] = MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] = MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] = MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] = MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys = Object.keys || function (o) {\n  var result = [];\n  for (var name in o) {\n    if (o.hasOwnProperty(name)) result.push(name);\n  }\n  return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MarkerClusterer);\n\n/***/ }),\n\n/***/ \"Ymb8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar getCurrentLocation = function getCurrentLocation() {\n  return new Promise(function (resolve, reject) {\n    if (!navigator.geolocation) {\n      reject(new Error('Tarayıcınız bu özelliği desteklememektedir.'));\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(function (position) {\n      resolve({ lat: position.coords.latitude, lon: position.coords.longitude });\n    }, function (error) {\n      var errorMessage = 'Bilinmeyen bir hata oluştu.';\n\n      switch (error.code) {\n        case error.PERMISSION_DENIED:\n          errorMessage = 'Bu özelliği kullanabilmek için izin vermeniz gerekmektedir.';\n          break;\n        case error.POSITION_UNAVAILABLE:\n          errorMessage = 'Şu an bu özelliği kullanamıyorsunuz.';\n          break;\n        case error.TIMEOUT:\n          errorMessage = 'Pozisyonunuz saptanırken bir hata meydana geldi.';\n          break;\n        default:\n          errorMessage = 'Bilinmeyen bir hata oluştu.';\n      }\n\n      reject(new Error(errorMessage));\n    });\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getCurrentLocation);\n\n/***/ }),\n\n/***/ \"gU42\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"lVK7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator__ = __webpack_require__(\"Xxa5\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_sfUi_css__ = __webpack_require__(\"gU42\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_sfUi_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__css_sfUi_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__css_snazzyInfoWindow_css__ = __webpack_require__(\"mLai\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__css_snazzyInfoWindow_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__css_snazzyInfoWindow_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__css_index_css__ = __webpack_require__(\"OGwZ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__css_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__css_index_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__map__ = __webpack_require__(\"zD9L\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__getCurrentLocation__ = __webpack_require__(\"Ymb8\");\n\n\nvar _this = this;\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n\n\n\n\n\n\n\nvar main = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.mark(function _callee2() {\n    var mapNode, map, markersData, markers, cluster, loading, filterLinks, showAll, nearLocationButton;\n    return __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            mapNode = document.getElementById('map');\n            map = Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"b\" /* createMap */])(mapNode);\n            _context2.next = 4;\n            return Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"d\" /* getMarkersData */])();\n\n          case 4:\n            markersData = _context2.sent;\n            markers = Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"c\" /* createMarkers */])(markersData);\n            cluster = Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"a\" /* createCluster */])(map, markers);\n            loading = document.getElementById('loading');\n\n            loading.remove();\n\n            // Filter Cluster & And counts\n            filterLinks = document.querySelectorAll('.high-school-type');\n\n            Array.from(filterLinks).forEach(function (filterLink) {\n              var type = filterLink.getAttribute('data-type');\n              var newMarkers = markers.filter(function (marker) {\n                return marker.schoolData.schoolType === type;\n              });\n\n              filterLink.setAttribute('data-balloon', newMarkers.length + ' tane bulunuyor.');\n              filterLink.setAttribute('data-balloon-pos', 'down');\n\n              filterLink.addEventListener('click', function (event) {\n                event.preventDefault();\n\n                markers.forEach(function (marker) {\n                  marker.info.close();\n                });\n\n                cluster.clearMarkers();\n                cluster = Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"a\" /* createCluster */])(map, newMarkers);\n                document.querySelector('.show-all-high-schools-container').style.display = 'block';\n              });\n            });\n\n            // Show all markers on cluster\n            showAll = document.getElementById('show-all-high-schools');\n\n            showAll.addEventListener('click', function (event) {\n              event.preventDefault();\n              cluster.clearMarkers();\n\n              markers.forEach(function (marker) {\n                marker.info.close();\n              });\n\n              cluster = Object(__WEBPACK_IMPORTED_MODULE_4__map__[\"a\" /* createCluster */])(map, markers);\n              document.querySelector('.show-all-high-schools-container').style.display = 'none';\n            });\n\n            // Get near location\n            nearLocationButton = document.getElementById('nearHighSchools');\n\n            nearLocationButton.addEventListener('click', _asyncToGenerator( /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.mark(function _callee() {\n              var position;\n              return __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.prev = 0;\n\n                      nearLocationButton.textContent = 'Bulunuyor...';\n                      nearLocationButton.disabled = true;\n\n                      _context.next = 5;\n                      return Object(__WEBPACK_IMPORTED_MODULE_5__getCurrentLocation__[\"a\" /* default */])();\n\n                    case 5:\n                      position = _context.sent;\n\n                      map.panTo(new google.maps.LatLng(position.lat, position.lon));\n                      map.setZoom(17);\n\n                      nearLocationButton.textContent = 'Yakınımdaki Okulları Bul';\n                      nearLocationButton.disabled = false;\n                      _context.next = 15;\n                      break;\n\n                    case 12:\n                      _context.prev = 12;\n                      _context.t0 = _context['catch'](0);\n\n                      // eslint-disable-next-line no-alert\n                      alert(_context.t0.message);\n\n                    case 15:\n                      _context.prev = 15;\n\n                      nearLocationButton.textContent = 'Yakınımdaki Okulları Bul';\n                      nearLocationButton.disabled = false;\n                      return _context.finish(15);\n\n                    case 19:\n                    case 'end':\n                      return _context.stop();\n                  }\n                }\n              }, _callee, _this, [[0, 12, 15, 19]]);\n            })));\n\n          case 15:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, _this);\n  }));\n\n  return function main() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nwindow.onload = main;\n\n/***/ }),\n\n/***/ \"mLai\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"zD9L\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return createMap; });\n/* unused harmony export getMarkerIcon */\n/* unused harmony export getMarkerInfoStyle */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return getMarkersData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return createMarkers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createCluster; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator__ = __webpack_require__(\"Xxa5\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_snazzy_info_window__ = __webpack_require__(\"KSzb\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_snazzy_info_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_snazzy_info_window__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__markerClusterer__ = __webpack_require__(\"RFWi\");\n\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _this = this;\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n\n\n\nvar TURKEY_POSITION = new google.maps.LatLng(38.963745, 35.243322);\nvar DEFAULT_ZOOM = 6;\nvar CLUSTER_OPTIONS = { imagePath: 'img/cluster/m' };\n\nvar createMap = function createMap(domNode) {\n  var map = new google.maps.Map(domNode, {\n    zoom: DEFAULT_ZOOM,\n    center: TURKEY_POSITION,\n    mapTypeId: google.maps.MapTypeId.ROADMAP,\n    mapTypeControlOptions: {\n      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\n      position: google.maps.ControlPosition.RIGHT_TOP\n    },\n    streetViewControl: false,\n    fullscreenControl: false\n  });\n\n  return map;\n};\n\nvar getMarkerIcon = function getMarkerIcon(type) {\n  switch (type) {\n    case 'anadolu_lisesi':\n      return 'img/anadolu_lisesi.svg';\n    case 'lise':\n      return 'img/diger_liseler.svg';\n    case 'fen_lisesi':\n      return 'img/fen_lisesi.svg';\n    case 'imam_hatip':\n      return 'img/imam_hatip_lisesi.svg';\n    case 'meslek_lisesi':\n      return 'img/meslek_lisesi.svg';\n    default:\n      return 'img/diger_liseler.svg';\n  }\n};\n\nvar getMarkerInfoStyle = function getMarkerInfoStyle(type) {\n  switch (type) {\n    case 'anadolu_lisesi':\n      return { backgroundColor: '#E8A213', color: '#fff' };\n    case 'lise':\n      return { backgroundColor: '#7C8894', color: '#fff' };\n    case 'fen_lisesi':\n      return { backgroundColor: '#177BF8', color: '#fff' };\n    case 'imam_hatip':\n      return { backgroundColor: '#35AD4E', color: '#fff' };\n    case 'meslek_lisesi':\n      return { backgroundColor: '#AC3434', color: '#fff' };\n    default:\n      return { backgroundColor: '#7C8894', color: '#fff' };\n  }\n};\n\nvar getMarkersData = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.mark(function _callee() {\n    var response, data;\n    return __WEBPACK_IMPORTED_MODULE_0__Users_alpcan_Projects_liseler_liseler_web_node_modules_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return fetch('data.json');\n\n          case 3:\n            response = _context.sent;\n            _context.next = 6;\n            return response.json();\n\n          case 6:\n            data = _context.sent;\n            return _context.abrupt('return', data);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context['catch'](0);\n\n            // eslint-disable-next-line no-alert\n            alert('Veri çekilirken bir hata meydana geldi.');\n            return _context.abrupt('return', []);\n\n          case 14:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, _this, [[0, 10]]);\n  }));\n\n  return function getMarkersData() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar createMarkers = function createMarkers(markersData) {\n  var markers = [];\n\n  markersData.forEach(function (data) {\n    var marker = new google.maps.Marker({\n      position: new google.maps.LatLng(data.lat, data.lon),\n      title: data.schoolName,\n      icon: getMarkerIcon(data.schoolType),\n      schoolData: data\n    });\n\n    // eslint-disable-next-line no-new\n    var info = new __WEBPACK_IMPORTED_MODULE_1_snazzy_info_window___default.a(_extends({\n      marker: marker,\n      placement: 'up',\n      content: '\\n        <div>\\n          <p class=\"pb-3 text-center school-title\">' + data.schoolName + '</p>\\n          <a href=\"' + data.website + '\" target=\"_blank\" class=\"button button-primary button-small d-block mb-2\">Web Sitesi</a>\\n          <a href=\"https://www.google.com/search?q=' + data.fullName + '\" target=\"_blank\" class=\"button button-secondary button-small d-block\">Google\\'da Ara</a>\\n        </div>\\n      ',\n      showCloseButton: false,\n      closeOnMapClick: true,\n      closeWhenOthersOpen: true,\n      border: false,\n      shadow: false,\n      maxWidth: 320,\n      padding: '35px'\n    }, getMarkerInfoStyle(data.schoolType)));\n\n    marker.info = info;\n\n    markers.push(marker);\n  });\n\n  return markers;\n};\n\nvar createCluster = function createCluster(map, markers) {\n  return new __WEBPACK_IMPORTED_MODULE_2__markerClusterer__[\"a\" /* default */](map, markers, CLUSTER_OPTIONS);\n};\n\n/***/ })\n\n},[0]);\n\n\n// WEBPACK FOOTER //\n// app.8931aec6.js","/* eslint-disable */\n\n// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0.1\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'imagePath': (string) The base URL where the images representing\n *                  clusters will be found. The full URL will be:\n *                  {imagePath}[1-5].{imageExtension}\n *                  Default: '../images/m'.\n *     'imageExtension': (string) The suffix for images URL representing\n *                       clusters will be found. See _imagePath_ for details.\n *                       Default: 'png'.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] || this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] || this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    // Determines map type and prevent illegal zoom levels\n    var zoom = that.map_.getZoom();\n    var minZoom = that.map_.minZoom || 0;\n    var maxZoom = Math.min(\n      that.map_.maxZoom || 100,\n      that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom,\n    );\n    zoom = Math.min(Math.max(zoom, minZoom), maxZoom);\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }.apply(obj1, [obj2]);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; (size = this.sizes[i]); i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size,\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; (marker = markers[i]); i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index,\n  };\n};\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  if (markers.length) {\n    for (var i = 0, marker; (marker = markers[i]); i++) {\n      this.pushMarkerTo_(marker);\n    }\n  } else if (Object.keys(markers).length) {\n    for (var marker in markers) {\n      this.pushMarkerTo_(markers[marker]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; (m = this.markers_[i]); i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  // create a local copy of markers if required\n  // (removeMarker_ modifies the getMarkers() array in place)\n  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;\n  var removed = false;\n\n  for (var i = 0, marker; (marker = markersCopy[i]); i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; (cluster = this.clusters_[i]); i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; (marker = this.markers_[i]); i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; (cluster = oldClusters[i]); i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n */\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) *\n      Math.cos(p2.lat() * Math.PI / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; (cluster = this.clusters_[i]); i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(\n    this.map_.getBounds().getSouthWest(),\n    this.map_.getBounds().getNorthEast(),\n  );\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; (marker = this.markers_[i]); i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(\n    this,\n    markerClusterer.getStyles(),\n    markerClusterer.getGridSize(),\n  );\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; (m = this.markers_[i]); i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; (marker = markers[i]); i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n/**\n * Returns the number of markers in the cluster.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n/**\n * Returns a list of the markers in the cluster.\n *\n * @return {Array.<google.maps.Marker>} The markers in the cluster.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; (marker = this.markers_[i]); i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (\n      typeof this.anchor_[0] === 'number' &&\n      this.anchor_[0] > 0 &&\n      this.anchor_[0] < this.height_\n    ) {\n      style.push(\n        'height:' + (this.height_ - this.anchor_[0]) + 'px; padding-top:' + this.anchor_[0] + 'px;',\n      );\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px;');\n    }\n    if (\n      typeof this.anchor_[1] === 'number' &&\n      this.anchor_[1] > 0 &&\n      this.anchor_[1] < this.width_\n    ) {\n      style.push(\n        'width:' + (this.width_ - this.anchor_[1]) + 'px; padding-left:' + this.anchor_[1] + 'px;',\n      );\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push(\n      'height:' +\n        this.height_ +\n        'px; line-height:' +\n        this.height_ +\n        'px; width:' +\n        this.width_ +\n        'px; text-align:center;',\n    );\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push(\n    'cursor:pointer; top:' +\n      pos.y +\n      'px; left:' +\n      pos.x +\n      'px; color:' +\n      txtColor +\n      '; position:absolute; font-size:' +\n      txtSize +\n      'px; font-family:Arial,sans-serif; font-weight:bold',\n  );\n  return style.join('');\n};\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] = MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] = MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] = MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] = MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] = MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] = MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] = MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] = MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] = MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] = MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] = MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] = MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] = MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] = MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\nObject.keys =\n  Object.keys ||\n  function(o) {\n    var result = [];\n    for (var name in o) {\n      if (o.hasOwnProperty(name)) result.push(name);\n    }\n    return result;\n  };\n\nexport default MarkerClusterer;\n\n\n\n// WEBPACK FOOTER //\n// ./src/markerClusterer.js","const getCurrentLocation = () =>\n  new Promise((resolve, reject) => {\n    if (!navigator.geolocation) {\n      reject(new Error('Tarayıcınız bu özelliği desteklememektedir.'));\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(\n      position => {\n        resolve({ lat: position.coords.latitude, lon: position.coords.longitude });\n      },\n      error => {\n        let errorMessage = 'Bilinmeyen bir hata oluştu.';\n\n        switch (error.code) {\n          case error.PERMISSION_DENIED:\n            errorMessage = 'Bu özelliği kullanabilmek için izin vermeniz gerekmektedir.';\n            break;\n          case error.POSITION_UNAVAILABLE:\n            errorMessage = 'Şu an bu özelliği kullanamıyorsunuz.';\n            break;\n          case error.TIMEOUT:\n            errorMessage = 'Pozisyonunuz saptanırken bir hata meydana geldi.';\n            break;\n          default:\n            errorMessage = 'Bilinmeyen bir hata oluştu.';\n        }\n\n        reject(new Error(errorMessage));\n      },\n    );\n  });\n\nexport default getCurrentLocation;\n\n\n\n// WEBPACK FOOTER //\n// ./src/getCurrentLocation.js","import './css/sfUi.css';\nimport './css/snazzyInfoWindow.css';\nimport './css/index.css';\n\nimport { createMap, getMarkersData, createMarkers, createCluster } from './map';\nimport getCurrentLocation from './getCurrentLocation';\n\nconst main = async () => {\n  const mapNode = document.getElementById('map');\n  const map = createMap(mapNode);\n\n  const markersData = await getMarkersData();\n  const markers = createMarkers(markersData);\n  let cluster = createCluster(map, markers);\n\n  const loading = document.getElementById('loading');\n  loading.remove();\n\n  // Filter Cluster & And counts\n  const filterLinks = document.querySelectorAll('.high-school-type');\n  Array.from(filterLinks).forEach(filterLink => {\n    const type = filterLink.getAttribute('data-type');\n    const newMarkers = markers.filter(marker => marker.schoolData.schoolType === type);\n\n    filterLink.setAttribute('data-balloon', `${newMarkers.length} tane bulunuyor.`);\n    filterLink.setAttribute('data-balloon-pos', 'down');\n\n    filterLink.addEventListener('click', event => {\n      event.preventDefault();\n\n      markers.forEach(marker => {\n        marker.info.close();\n      });\n\n      cluster.clearMarkers();\n      cluster = createCluster(map, newMarkers);\n      document.querySelector('.show-all-high-schools-container').style.display = 'block';\n    });\n  });\n\n  // Show all markers on cluster\n  const showAll = document.getElementById('show-all-high-schools');\n  showAll.addEventListener('click', event => {\n    event.preventDefault();\n    cluster.clearMarkers();\n\n    markers.forEach(marker => {\n      marker.info.close();\n    });\n\n    cluster = createCluster(map, markers);\n    document.querySelector('.show-all-high-schools-container').style.display = 'none';\n  });\n\n  // Get near location\n  const nearLocationButton = document.getElementById('nearHighSchools');\n  nearLocationButton.addEventListener('click', async () => {\n    try {\n      nearLocationButton.textContent = 'Bulunuyor...';\n      nearLocationButton.disabled = true;\n\n      const position = await getCurrentLocation();\n      map.panTo(new google.maps.LatLng(position.lat, position.lon));\n      map.setZoom(17);\n\n      nearLocationButton.textContent = 'Yakınımdaki Okulları Bul';\n      nearLocationButton.disabled = false;\n    } catch (err) {\n      // eslint-disable-next-line no-alert\n      alert(err.message);\n    } finally {\n      nearLocationButton.textContent = 'Yakınımdaki Okulları Bul';\n      nearLocationButton.disabled = false;\n    }\n  });\n};\n\nwindow.onload = main;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import SnazzyInfoWindow from 'snazzy-info-window';\nimport MarkerClusterer from './markerClusterer';\n\nconst TURKEY_POSITION = new google.maps.LatLng(38.963745, 35.243322);\nconst DEFAULT_ZOOM = 6;\nconst CLUSTER_OPTIONS = { imagePath: 'img/cluster/m' };\n\nexport const createMap = domNode => {\n  const map = new google.maps.Map(domNode, {\n    zoom: DEFAULT_ZOOM,\n    center: TURKEY_POSITION,\n    mapTypeId: google.maps.MapTypeId.ROADMAP,\n    mapTypeControlOptions: {\n      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\n      position: google.maps.ControlPosition.RIGHT_TOP,\n    },\n    streetViewControl: false,\n    fullscreenControl: false,\n  });\n\n  return map;\n};\n\nexport const getMarkerIcon = type => {\n  switch (type) {\n    case 'anadolu_lisesi':\n      return 'img/anadolu_lisesi.svg';\n    case 'lise':\n      return 'img/diger_liseler.svg';\n    case 'fen_lisesi':\n      return 'img/fen_lisesi.svg';\n    case 'imam_hatip':\n      return 'img/imam_hatip_lisesi.svg';\n    case 'meslek_lisesi':\n      return 'img/meslek_lisesi.svg';\n    default:\n      return 'img/diger_liseler.svg';\n  }\n};\n\nexport const getMarkerInfoStyle = type => {\n  switch (type) {\n    case 'anadolu_lisesi':\n      return { backgroundColor: '#E8A213', color: '#fff' };\n    case 'lise':\n      return { backgroundColor: '#7C8894', color: '#fff' };\n    case 'fen_lisesi':\n      return { backgroundColor: '#177BF8', color: '#fff' };\n    case 'imam_hatip':\n      return { backgroundColor: '#35AD4E', color: '#fff' };\n    case 'meslek_lisesi':\n      return { backgroundColor: '#AC3434', color: '#fff' };\n    default:\n      return { backgroundColor: '#7C8894', color: '#fff' };\n  }\n};\n\nexport const getMarkersData = async () => {\n  try {\n    const response = await fetch('data.json');\n    const data = await response.json();\n\n    return data;\n  } catch (err) {\n    // eslint-disable-next-line no-alert\n    alert('Veri çekilirken bir hata meydana geldi.');\n    return [];\n  }\n};\n\nexport const createMarkers = markersData => {\n  const markers = [];\n\n  markersData.forEach(data => {\n    const marker = new google.maps.Marker({\n      position: new google.maps.LatLng(data.lat, data.lon),\n      title: data.schoolName,\n      icon: getMarkerIcon(data.schoolType),\n      schoolData: data,\n    });\n\n    // eslint-disable-next-line no-new\n    const info = new SnazzyInfoWindow({\n      marker,\n      placement: 'up',\n      content: `\n        <div>\n          <p class=\"pb-3 text-center school-title\">${data.schoolName}</p>\n          <a href=\"${\n            data.website\n          }\" target=\"_blank\" class=\"button button-primary button-small d-block mb-2\">Web Sitesi</a>\n          <a href=\"https://www.google.com/search?q=${\n            data.fullName\n          }\" target=\"_blank\" class=\"button button-secondary button-small d-block\">Google'da Ara</a>\n        </div>\n      `,\n      showCloseButton: false,\n      closeOnMapClick: true,\n      closeWhenOthersOpen: true,\n      border: false,\n      shadow: false,\n      maxWidth: 320,\n      padding: '35px',\n      ...getMarkerInfoStyle(data.schoolType),\n    });\n\n    marker.info = info;\n\n    markers.push(marker);\n  });\n\n  return markers;\n};\n\nexport const createCluster = (map, markers) => new MarkerClusterer(map, markers, CLUSTER_OPTIONS);\n\n\n\n// WEBPACK FOOTER //\n// ./src/map.js"],"sourceRoot":""}